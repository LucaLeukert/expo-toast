#!/usr/bin/env node
import { mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import process from 'node:process';
import ts from 'typescript';

const root = process.cwd();
const checkOnly = process.argv.includes('--check');

const entryPath = resolve(root, 'src/index.ts');
const tsconfigPath = resolve(root, 'tsconfig.json');
const outputPath = resolve(root, 'docs/src/content/docs/reference/api.mdx');

function normalize(content) {
  return `${content.replace(/\r\n/g, '\n').trimEnd()}\n`;
}

function ensureDir(filePath) {
  mkdirSync(dirname(filePath), { recursive: true });
}

function escaped(text) {
  return text.replaceAll('|', '\\|').trim();
}

function docText(symbol, checker) {
  return ts.displayPartsToString(symbol.getDocumentationComment(checker)).trim();
}

function memberDoc(member, checker) {
  const symbol = member.name ? checker.getSymbolAtLocation(member.name) : undefined;
  if (!symbol) {
    return '';
  }
  return docText(symbol, checker);
}

function unwrapAlias(symbol, checker) {
  if (symbol.flags & ts.SymbolFlags.Alias) {
    return checker.getAliasedSymbol(symbol);
  }
  return symbol;
}

function compareByName(a, b) {
  const aName = a.getName();
  const bName = b.getName();
  if (aName < bName) {
    return -1;
  }
  if (aName > bName) {
    return 1;
  }
  return 0;
}

function renderFunctionSignature(symbol, checker, declaration) {
  const signatures = checker.getTypeOfSymbolAtLocation(symbol, declaration).getCallSignatures();
  if (signatures.length === 0) {
    return `${symbol.getName()}(...)`;
  }
  const signature = checker.signatureToString(
    signatures[0],
    undefined,
    ts.TypeFormatFlags.NoTruncation,
  );
  return `${symbol.getName()}${signature}`;
}

function renderVariableSignature(symbol, checker, declaration) {
  const type = checker.getTypeOfSymbolAtLocation(symbol, declaration);
  const typeText = checker.typeToString(type, declaration, ts.TypeFormatFlags.NoTruncation);
  return `${symbol.getName()}: ${typeText}`;
}

function renderTypeAliasSignature(declaration) {
  const normalizedType = declaration.type.getText().replace(/\s+/g, ' ').trim();
  return `type ${declaration.name.getText()} = ${normalizedType}`;
}

function renderInterfaceMemberSignatures(declaration, checker) {
  const out = [];
  for (const member of declaration.members) {
    if (!member.name) {
      continue;
    }
    const signature = member.getText().replace(/\s+/g, ' ').trim();
    const docs = memberDoc(member, checker);
    out.push({
      signature,
      docs,
    });
  }
  return out;
}

function renderMarkdown(api) {
  const lines = [
    '---',
    'title: API (JSDoc)',
    'description: Auto-generated from JSDoc comments in src/.',
    'slug: reference/api',
    '---',
    '',
    '_This page is generated by `scripts/sync-api-docs.mjs`. Do not edit manually._',
    '',
  ];

  if (api.functions.length > 0) {
    lines.push('## Functions', '');
    for (const entry of api.functions) {
      lines.push(`### \`${escaped(entry.signature)}\``, '');
      lines.push(entry.docs || 'No documentation provided.', '');
    }
  }

  if (api.variables.length > 0) {
    lines.push('## Objects', '');
    for (const entry of api.variables) {
      lines.push(`### \`${escaped(entry.signature)}\``, '');
      lines.push(entry.docs || 'No documentation provided.', '');
    }
  }

  if (api.interfaces.length > 0) {
    lines.push('## Interfaces', '');
    for (const entry of api.interfaces) {
      lines.push(`### \`${escaped(entry.signature)}\``, '');
      lines.push(entry.docs || 'No documentation provided.', '');
      if (entry.members.length > 0) {
        lines.push('#### Members', '');
        for (const member of entry.members) {
          lines.push(`- \`${escaped(member.signature)}\`${member.docs ? ` - ${member.docs}` : ''}`);
        }
        lines.push('');
      }
    }
  }

  if (api.typeAliases.length > 0) {
    lines.push('## Type Aliases', '');
    for (const entry of api.typeAliases) {
      lines.push(`### \`${escaped(entry.signature)}\``, '');
      lines.push(entry.docs || 'No documentation provided.', '');
    }
  }

  return normalize(lines.join('\n'));
}

function main() {
  const configFile = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
  if (configFile.error) {
    throw new Error(ts.flattenDiagnosticMessageText(configFile.error.messageText, '\n'));
  }

  const parsed = ts.parseJsonConfigFileContent(configFile.config, ts.sys, root);
  const program = ts.createProgram({
    rootNames: parsed.fileNames,
    options: parsed.options,
  });
  const checker = program.getTypeChecker();
  const sourceFile = program.getSourceFile(entryPath);

  if (!sourceFile) {
    throw new Error(`Unable to load entrypoint: ${entryPath}`);
  }

  const moduleSymbol = checker.getSymbolAtLocation(sourceFile);
  if (!moduleSymbol) {
    throw new Error(`Unable to resolve module symbol for: ${entryPath}`);
  }

  const api = {
    functions: [],
    variables: [],
    interfaces: [],
    typeAliases: [],
  };

  const exports = checker
    .getExportsOfModule(moduleSymbol)
    .filter((symbol) => symbol.getName() !== 'default')
    .sort(compareByName);

  for (const exportSymbol of exports) {
    const symbol = unwrapAlias(exportSymbol, checker);
    const declaration = symbol.getDeclarations()?.[0];
    if (!declaration) {
      continue;
    }

    const docs = docText(symbol, checker);
    switch (declaration.kind) {
      case ts.SyntaxKind.FunctionDeclaration:
        api.functions.push({
          signature: renderFunctionSignature(symbol, checker, declaration),
          docs,
        });
        break;
      case ts.SyntaxKind.VariableDeclaration:
        api.variables.push({
          signature: renderVariableSignature(symbol, checker, declaration),
          docs,
        });
        break;
      case ts.SyntaxKind.InterfaceDeclaration:
        api.interfaces.push({
          signature: `interface ${symbol.getName()}`,
          docs,
          members: renderInterfaceMemberSignatures(declaration, checker),
        });
        break;
      case ts.SyntaxKind.TypeAliasDeclaration:
        api.typeAliases.push({
          signature: renderTypeAliasSignature(declaration),
          docs,
        });
        break;
      default:
        break;
    }
  }

  const rendered = renderMarkdown(api);
  ensureDir(outputPath);

  if (checkOnly) {
    let current = '';
    try {
      current = readFileSync(outputPath, 'utf8');
    } catch {
      throw new Error(`Missing synced API doc: ${outputPath}`);
    }

    if (normalize(current) !== rendered) {
      throw new Error(`Out-of-sync API doc: ${outputPath}. Run \`bun run docs:sync\`.`);
    }
    return;
  }

  writeFileSync(outputPath, rendered);
  console.log('Synced API docs from JSDoc comments');
}

try {
  main();
} catch (error) {
  console.error(String(error instanceof Error ? error.message : error));
  process.exit(1);
}
